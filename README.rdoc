= DoesKeyValue

NoSQL-like key value stores in SQL-backed ActiveRecord objects. Arbitrary keys behave 
like dynamic, indexable, searchable first-order attributes.

== Deprecation Notice

DoesKeyValue is undergoing a substantial API change. The old branch of work (v0.2.*) is
now referred to as the "Albus" branch and the new line of work (v0.9.0+) is referred to
as the "Bellatrix" branch. Review accordingly.

When ready, the Bellatrix code will be moved into the master branch and the Albus/v0.2
branch will no longer be supported.

This documentation refers to the Bellatrix/v0.9+ branch and its corresponding API.


== Installation

Do the usual, of course:

  gem install doeskeyvalue

And add a gem dependency to your Gemfile:

  gem "doeskeyvalue"


== Column-Based Storage Example 

In any ActiveRecord model in which you'd like to have key-value support, you simply
declare your intention to declare keys:

  does_keys :column=>"settings"
  
In this invocation, "settings" is the name of TEXT or BLOB field on your model's database
table. Think of it as something you'd typically serialize, but would prefer solid accessor 
and finding behavior on.

Add keys to your document field individually like so:

  has_key :email                            # Default type is string
  has_key :uid, :type=>:integer             # But type can be overidden easily
  has_key :city, :default=>"Awesomeville"   # You can also declare default values

This adds email, uid, and city fields to your record. You can use these fields just like regular 
columns on your ActiveRecord object, but they're happily stored within your TEXT/BLOB column at 
the database level. Check it out:

  mod = Model.new
  
  mod.email = "me@awexo.me"
  => "me@awexo.me"
  
  mod.email
  => "me@awexo.me"
  
You can see the serialized key-value structure at any time, as well. Just access your old field:

  mod.settings
  => {:email=>"me@awexo.me"}


== Table-Based Storage Example

For larger key sets, you may find it advantageous to move your key-value storage into a separate
database table, instead of the baked-in serialized column. You can do this quite easily by using
a different flag in your initialization call:

  does_keys :table=>"user_preferences"

In this example, we're storing our key-value pairs as their own independent rows within the
user_preferences database table. You declare keys and manipulate values in exactly the same way
as before:

  has_key :bgcolor, :default=>"blue"
  has_key :birthday, :type=>:datetime
  has_key :likes_ice_cream, :type=>:boolean, :default=>true

  mod.likes_ice_cream
  => true

  mod.likes_ice_cream = false
  => false

  mod.bgcolor
  => "blue"


== Search and Lookups

At this point, you've seen how flexible the key-value storage mechanism can be. You can add and
remove keys at will, and manipulate data just like typical ActiveRecord attributes. But how do
you search across that data?

You can use scope finders for all of your declared keys. Observe:

  has_key :email
  has_key :name

  Model.with_name("Charlie")
  => [#<Model:0x000001016b51a0 @settings=>{:name=>"Charlie"}>]

  Model.with_name(["Charlie","Mac","Dennis","Dee"])
  => [#<Model:0x000001016b51a0 @settings=>{:name=>"Charlie"}>, #<Model:0x000001016b51a0 @settings=>{:name=>"Dee"}>, ...]

All keys are indexed by default. You can turn indexing off for any individual key by sending a 
flag to the key declaration:

  has_key :bgcolor, :index=>false             # This turns off searchability for the bgcolor key

Indexing key-value columns adds a bit of overhead to your save and update method callbacks, which
you may want to turn off in larger systems for keys where searching is not required.




== Copyright

Copyright (c) 2012 Awexome Labs, LLC. http://awexomelabs.com/
